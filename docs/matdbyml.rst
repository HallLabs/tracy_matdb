`matdb.yml` Database Specification File
=======================================

.. note:: At the moment, `matdb` only supports calculation using VASP to get DFT
	  energies, forces, virials and hessian matrices.

`matdb.yml` tracks the specification for a set of databases that
together represent all example configurations for generating an
interatomic potential. :doc:`databases` discusses the database types
and how they work. In this document, we are interested mainly in how
to configure their options. The following options are available at the
top-level of the YAML file:

1. **title**: user-selected identifier for the particular config
   database.
2. **species**: describes which elements are used to generate the
   configurations.
3. **potcars**: describes which pseudopotentials to use for each of
   the elements in the calculation.
4. **root**: where to store the folders generated by `matdb`.
5. **calculator**: describes the *default* parameters for the `ase`
   calculator including the k-point selection method and density; this
   can be overridden at the database level.
6. **execution**: HPC parameters for the jobs that will be created
   when running each of the databases. By default, only `sbatch` is
   supported.
7. **databases**: list of databases to generate for each of the
   configurations specified in the `config` option.
8. **training**: parameters for each of the GAP models that will be
    combined to generate the interatomic potential.
9. **splits**: allows for the databases created to be split multiple
   ways for training and validation tests.

`species` Option
----------------

The kinds of elements described in this list must be given in the
order that they appear in the POSCAR files. For example:

.. code-block:: yaml
		
   species:
     - 'Pd'
     - 'Ag'

will generate POTCAR files with the `Pd` pseudopotential first.

`potcars` Option
----------------

In order to generate the folders for the DFT calculations, `matdb`
needs to know where the POTCARs are and which one to use for each
element. By default, the POTCAR is selected based on the species
name. However, some species have multiple pseudopotentials defined. In
this case, the *suffix* for the pseudopotential file (i.e., everything
after the element name) can be specified by including the *setups* key
containing a the dictionary with the lower-case of the element and its
suffix. The POTCARs are constructed using the `ase` contructor.

.. code-block:: yaml
		
   potcars:
     directory: '/fslhome/glh43/src/vasp'
     xc: 'PBE'
     version: '04Jan2005'
     setups:
       Pd: '_pv'

- `directory` is the full path to the folder that contains all the
  pseudopotential types.
- `xc` specifies the type of pseudopotential to use. For VASP,
  LDA, GGA and PBE are available, though other custom implementations
  may also be available.
- `version` is the date of the pseudopotential. `matdb` will make sure
  that the pseudopotentials used match this date to avoid mixing
  incompatible potentials.
- `setups` is a dictionary of element suffix pairs for selecting which
  POTCAR to choose from those available. `Pd` is provided here as an
  example.

`calculator` Option
--------------

Default parameters for `ase` calculator can be specified using
`calculator`. The options have exactly the same names as they would
have in the relavent input file and accept values as expected.

.. code-block:: yaml

   calculator:
     name: Vasp
     nsw: 1
     pp: 'pbe'
     kpoints:
       method: 'mueller'
       mindistance: 30

- `name` is the name of the `ase` calculator to be used. Currently
  only Vasp, and Quippy calculators are support.
- `nsw` an example INCAR parameter for VASP.
- `pp` a marker to let the `ase` calculator know which
  potential types are in use.
- `kpoints` specifies the k-point selection method and density. The
  `method` flag determines which method will be used. For the
  'mueller' method the density or k-point spacing is set by the
  `mindistance` flag.

.. note:: These parameters can be overridden by any of the database
   specifications recorded later in the YAML file.

`execution` Option
------------------

`matdb` uses templates to build the bash files that submit jobs for
execution. It ships with templates that work with the SBATCH system,
but the templates can be adjusted easily using those as an
example. This dictionary has fields corresponding to the fields in the
template, and the values will be inserted directly.

Since database generation involves many calculations, the files are
setup to use job arrays by default.

- **template**: name of the file in the `matdb/templates` directory
  to use as the execution template.
- **time**: time in *hours* to run each job in the array for.
- **ntasks**: number of CPUs to request.
- **nodes**: number of nodes to spread CPUs over.
- **mem_per_cpu**: Amount of memory in *GB* for each CPU.
- **job_name**: job name for the scheduler.
- **partition**: QOS or special partition/queue to run the calculations on.
- **array_limit**: what is the maximum number of jobs to run concurrently.
- **exec_path**: path to the VASP executable to run in each directory
  that `matdb` sets up.
- **module_unload**: a list of modules to unload using `module unload
  {}`.
- **module_load**: a list of modules to *load* using `module load
  {}`.
- **preamble**: additional lines to insert into the job script
  *before* the executable.


For the preamble, you can use multi-line strings in YAML like:

.. code-block:: yaml

   preamble: >
     first line
     second line
     and so on...

`databases` Option
------------------

`matdb` will generate a database according to settings in this
section.

.. note:: The options specified in the configuration file are usually
   passed directly as keyword arguments to the relevant class
   constructors. You can look at the class documentation for more
   details.

.. note:: All databases have a `name` argument that you can
   specify. If not given, a default will be chosen for you.
   
This option takes a list of dictionaries, where each dictionary has
settings peculiar to the type of database being constructed. Each
database can include multiple database types using the `steps` command
allowing for the linking of databases whose calculations rely on each
other.

Some of the database classes are seeded, i.e., need an initial
starting configuration to run. These seed configurations should be
located in a folder calleds "SEED" in the root database directory. The
configurations will be passed to the databases using the `seeds` key
word wich takes a list of strings with format *"file format: file
name"*.

.. note:: You can override the `execution` and `calculator` settings
   for a particular database by including an option in its dictionary
   that is formatted exactly the same way as described above. However,
   you do *not* need to include all options, only those you need to
   override must be specified.

Basic Phonon Database
*********************

In order to generate a dynamical matrix, several perturbed
configurations need to be generated using `phonopy`, each of these can
then be calculated with DFT to high accuracy and the resulting force
sets are used to approximate the second derivatives.

The :class:`~matdb.databases.phonons.PhononDFT` class generates these
configurations and sets up the VASP folders and execution
templates. For example:

.. code-block:: yaml

   steps:
     - type: 'phonon.PhononDFT'
       seeds: ["POSCAR:PdAg25","POSCAR:PdAgp0","POSCAR:PdAg75"]
       kpoints:
         mindistance: 30
         seeds: 
       phonons:
         dim: [2, 2, 2]
         mp: [20, 20, 20]

tells `matdb` to calculate the dynamical matrix for each of the
configurations listed in `seeds` using a relatively high kpoint
density, a `2x2x2` supercell and Monkhorst-Pack sampling of the BZ
with density `20x20x20`. The `type` parameter specifies the qualified
name of the sub-class that implements the database logic (relative to
`matdb.database`). The `MP` sampling is used to generate the DFT
answer for the phonon bands that will be plotted alongside the fitted
potentials later on.


Phonon Modulated Database
*************************

Once the dynamical matrices are available for each configuration, we
can module the seed configs to generate lots of unique structures for
training.

.. code-block:: yaml
		
   steps:
     - type: 'phonon.PhononDatabase'
       seeds: ["POSCAR:PdAg25","POSCAR:PdAgp0","POSCAR:PdAg75"]
       nconfigs: 500
       sampling: 'uniform'
       dftbase: 'phondft'
       calibrator: 'phoncalib'
       #calibrate: 9
       phonons:
         dim: [2, 2, 2]
         mesh: [13, 13, 13]
       amplitude:
         PdAg25: 15
         PdAg50: 12
         PdAg75: 18

The `type` option once again points to a specific sub-class that
implements the database logic. Next, we specify the number of
configurations to generate (via random modulations) and how to sample
the frequency space of the phonons. For a given frequency, we can
extract an eigenvector that is used to modulate the atomic positions. By
default, we sample the available frequencies in the BZ uniformly so
that both high and low freuency phonon modulations are used.

.. warning:: If you don't specify an argument for `dftbase` it
   defaults to `phondft` (the default name of
   :class:`~matdb.database.phonon.PhononDFT`). If you have multiple
   DFT bases with different parameters, make sure you keep the names
   straight.

The `calibrate` option sets up another database in the background to
calibrate the amplitudes of the modulations. The name of this database
defaults to `phoncalib`, but you can specify a different one by
specifying a value for `calibrator`. As shown in this example, you can
also specify the `amplitude` manually for each configuration. If
`amplitude` is not specified `matdb` will try to find the amplitude
automatically using the calibration database.

Calibration creates a set of modulated configurations for a random
frequency and displaces the atoms using a logarithmic space from 1
until `10^1.7` (largest number that made sense in our
experiments). We then look at forces for each configuration and choose
the largest amplitude for which the forces are still in the linear
regime.

The supercell is still specified using `dim` (in this case `2x2x2`),
but the DOS sampling for frequencies to module with happens on the
specified grid (specified by `mesh`). By choosing a finer mesh, the
resolution (and number) of frequency samples in the DOS
increases. Modulations are chosen from this distribution according to
the `sampling` setting.

Liquid Database
***************

Liquid databases are constructed using sub-sampled MD calculations.

.. code-block:: yaml

   steps:		
     - type: 'liquid.LiquidDatabase'
       seeds: ["POSCAR:PdAg25","POSCAR:PdAgp0","POSCAR:PdAg75"]
       nconfigs: 1000
       samplerate: 100
       tstart:
         PdAg25: 2766
         PdAg50: 3063
         PdAg75: 3360
       tend:
         PdAg25: 2800
         PdAg50: 3100
         PdAg75: 3400
       calculator:
         smass: 3
         potim: 1.

This tells `matdb` to run molecular dynamics for `1000 x 100` fs to
generate 1000 subsamples at intervals of 100 fs. The starting
temperature `tstart` for each seed configuration is set to be close to
its melting point. `tend` specifies the end temperature. These
settings are passed directly to the DFT calculation and behave as
documented there.

Notice that we also need to update some `calculator` parameters to get
MD to work. We don't have to specify all of them because the defaults
from earlier in the specification will be used if not overridden.

Enumerated Database
***************

An enumerated database is one constructed from a random sampling of
the symmetryically unique arrangements of the `species` on a lattice
given by the user.

.. code-block:: yaml

   steps:		
     - type: 'enumerated.Enumerated'
       lattice*:
         - "bcc"
	 - "fcc"
       lattice_suffix*:
         - "bcc"
	 - "fcc"
       nconfigs: 10
       sizes: [1,4]
       rattle: 0.01

This tells `matdb` to enumerate the symmetrically unique
configurations of an fcc and bcc lattice, for volume factors of 1 to 4
times the parent cell volume, and select 10 configurations from each
lattice. Notice that we've used the `lattice*` flag to indicate that
we're listing multiple options for the lattice. This can be done with
any key word in any `matdb` database to create as diverse of a
sampling scheme as the user desires.

The `lattice_suffix*` flag tells `matdb` what to call the directory in
which each lattice's sampling will occure. In this case two
directories will be created 'lat-fcc' and 'lat-bcc' in which the
sampled configurations from each lattice will be stored.

`training` Options
******************

Once a database of configurations is available, `matdb` can automate
the fits for you using these settings.

.. code-block:: yaml
		
   training:
     configs: ['PdAg25', 'PdAg50', 'PdAg75']
     execution:
       template: 'run_teachsparse_ml.sh'
       time: 10
       ntasks: 8
       mem_per_cpu: 5
       job_name: 'AgPd GAP'
     split: 0.5
     hessian_delta: 0.01
     gap: ['2body', '3body', 'soap']
     2body:
       cutoff: 6.0
       cutoff_transition_width: 1.0
       n_sparse: 20
     3body:
       cutoff: 3.5
       cutoff_transition_width: 0.5
       n_sparse: 200
     soap:
       l_max: 12
       n_max: 12
       cutoff: 5.0
       n_sparse: 200
       sparse_method: 'file'


- **configs**: list of the seed configs to include in the fit; the
  combined databases for each of these configs become the training
  data for the fit.
- **execution**: as described above, this specifies the template for
  executing the fits.
- **split**: how much data to use for training vs. validation.
- **hessian_delta**: if a hessian fit should be performed, then this
  is the delta to include. Specifying a delta here causes `matdb` to
  generate some hard-coded sparse points to include as a file in the
  `soap` fit (which corresponds to `sparse_method=file`).
- **gap**: list of GAP models to include in the final potential.

For each of the potential types specified in `gap` you can then add a
dictionary with parameters specific to that GAP (and which are passed
into the `teach_sparse` program). These work as documented there.

Full Example File
-----------------

.. literalinclude:: matdb.yml
   :language: yaml
   :linenos:

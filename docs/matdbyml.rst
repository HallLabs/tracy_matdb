`matdb.yml` Database Specification File
=======================================

.. note:: At the moment, `matdb` only supports calculation using VASP to get DFT
	  energies, forces, virials and hessian matrices.

`matdb.yml` tracks the specification for a set of databases that
together represent all example configurations for generating an
interatomic potential. :doc:`databases` discusses the database types
and how they work. In this document, we are interested mainly in how
to configure their options. The following options are available at the
top-level of the YAML file:

1. **title**: user-selected identifier for the particular config
   database.
2. **species**: describes which elements are used to generate the
   configurations.
3. **potcars**: describes which pseudopotentials to use for each of
   the elements in the calculation.
4. **root**: where to store the folders generated by `matdb`.
5. **configs**: basic or "seed" configurations to use for in
   generating additional configurations.
6. **incar**: describes the *default* parameters for the `INCAR` file
   in VASP; this can be overridden at the database level.
7. **kpoints**: parameters for defining how KPOINTS are selected for
   the DFT calculation.
8. **execution**: HPC parameters for the jobs that will be created
   when running each of the databases. By default, only `sbatch` is
   supported.
9. **databases**: list of databases to generate for each of the
   configurations specified in the `config` option.
10. **training**: parameters for each of the GAP models that will be
    combined to generate the interatomic potential.

`species` Option
----------------

The kinds of elements described in this list must be given in the
order that they appear in the POSCAR files. For example:

.. code-block:: yaml
		
   species:
     - 'Pd'
     - 'Ag'

will generate POTCAR files with the `Pd` pseudopotential first.

`potcars` Option
----------------

In order to generate the folders for the DFT calculations, `matdb`
needs to know where the POTCARs are and which one to use for each
element. By default, the POTCAR is selected based on the species
name. However, some species have multiple pseudopotentials defined. In
this case, the *suffix* for the pseudopotential file (i.e., everything
after the element name) can be specified by including a key in the
dictionary with the lower-case name of the element and its suffix.

.. code-block:: yaml
		
   potcars:
     directory: '/fslhome/glh43/src'
     pseudo: 'paw_PBE'
     version: '04Jan2005'
     pd: '_pv'

- `directory` is the full path to the folder that contains all the
  pseudopotential types.
- `pseudo` specifies the type of pseudopotential to use. For VASP,
  LDA, GGA and PBE are available, though other custom implementations
  may also be available.
- `version` is the date of the pseudopotential. `matdb` will make sure
  that the pseudopotentials used match this date to avoid mixing
  incompatible potentials.
- `pd` is an example of overriding the pseudopotential to use for
  `Pd`. Use the lower-case name of the element and then the suffix for
  the file as described above.

`configs` Option
----------------

Here you specify each of the seed configurations to use for generating
databases. A seed configuration means different things depending on
the database type being generated. For example, phonon databases are
created by calculating the dynamical matrix for the seed configuration
(using DFPT) and then creating random modulations along the
eigenvector directions for the structure. Liquid databases use the
seed configuration as the starting point for a high-temperature
molecular dynamics run.

This option accepts a list of dictionaries where each dictionary has:

1. **name**: user-selected name for the configuration.
2. **poscar**: relative path of the POSCAR to `root`.

For example:

.. code-block:: yaml
		
   configs:
     - name: 'PdAg25'
       poscar: 'POSCAR-25'
     - name: 'PdAg50'
       poscar: 'POSCAR-50'
     - name: 'PdAg75'
       poscar: 'POSCAR-75'

sets up 3 seed configurations for the POSCAR files at
`<root>/POSCAR-25`, `<root>/POSCAR-50` and `<root>/POSCAR-75`.

`incar` Option
--------------

Default parameters for VASP calculations can be specified using
`incar`. The options have exactly the same names as they would have in
the INCAR file and accept values as expected.

.. note:: These parameters can be overridden by any of the database
   specifications recorded later in the YAML file.

`kpoints` Option
----------------

As for `incar`, you can specify how the KPOINTS should be chosen for
the DFT calculations. At the moment, only the Mueller kpoint scheme is
supported and the keywords are exactly as they would be specified in
the PRECALC file.

`execution` Option
------------------

`matdb` uses templates to build the bash files that submit jobs for
execution. It ships with templates that work with the SBATCH system,
but the templates can be adjusted easily using those as an
example. This dictionary has fields corresponding to the fields in the
template, and the values will be inserted directly.

Since database generation involves many calculations, the files are
setup to use job arrays by default.

-  **template**: name of the file in the `matdb/templates` directory
   to use as the execution template.
-  **time**: time in *hours* to run each job in the array for.
-  **ntasks**: number of CPUs to request.
-  **nodes**: number of nodes to spread CPUs over.
-  **mem_per_cpu**: Amount of memory in *GB* for each CPU.
-  **job_name**: job name for the scheduler.
-  **partition**: QOS or special partition/queue to run the calculations on.
-  **array_limit**: what is the maximum number of jobs to run concurrently.
-  **exec_path**: path to the VASP executable to run in each directory
   that `matdb` sets up.

`databases` Option
------------------

For each of the configurations specified in the `configs` section,
`matdb` will generate a database of configurations according to
settings in this section.

This option takes a list of dictionaries, where each dictionary has
settings peculiar to the type of database being constructed.

.. note:: You can override the `execution`, `incar` and `kpoints`
   settings for a particular database by including an option in its
   dictionary that is formatted exactly the same way as described
   above. However, you do *not* need to include all options, only
   those you need to override must be specified.

Basic Phonon Database
*********************

In order to generate a dynamical matrix, several perturbed
configurations need to be generated using `phonopy`, each of these can
then be calculated with DFT to high accuracy and the resulting force
sets are used to approximate the second derivatives.

The :class:`~matdb.databases.phonons.PhonBase` class generates these
configurations and sets up the VASP folders and execution
templates. For example:

.. code-block:: yaml
		
   - type: 'phonon.PhononBase'
     kpoints:
       mindistance: 30
     phonons:
       dim: [2, 2, 2]
       mp: [20, 20, 20]

tells `matdb` to calculate the dynamical matrix for each of the
configurations using a relatively high kpoint density, a `2x2x2`
supercell and Monkhorst-Pack sampling of the BZ with density
`20x20x20`. The `type` parameter specifies the qualified name of the
sub-class that implements the database logic (relative to
`matdb.database`). The `MP` sampling is used to generate the DFT
answer for the phonon bands that will be plotted alongside the fitted
potentials later on.

Phonon Modulated Database
*************************

Once the dynamical matrices are available for each configuration, we
can module the seed configs to generate lots of unique structures for
training.

.. code-block:: yaml
		
   - type: 'phonon.PhononDatabase'
     nconfigs: 500
     sampling: 'uniform'
     #calibrate: 9
     phonons:
       dim: [2, 2, 2]
       mesh: [13, 13, 13]
     amplitude:
       PdAg25: 15
       PdAg50: 12
       PdAg75: 18

The `type` option once again points to a specific sub-class that
implements the database logic. Next, we specify the number of
configurations to generate (via random modulations) and how to sample
the frequency space of the phonons. For a given frequency, we can
extract an eigenvector that is used to module the atomic positions. By
default, we sample the available frequencies in the BZ uniformly so
that both high and low freuency phonon modulations are used.

The `calibrate` option sets up another database in the background to
calibrate the amplitudes of the modulations. As shown in this example,
you can also specify the `amplitude` manually for each
configuration. If `amplitude` is not specified `matdb` will try to
find the amplitude automatically using the calibration
database.

Calibration creates a set of modulated configurations for a random
frequency and displaces the atoms using a logarithmic space from 1
until `10^1.7` (largest number that made sense in our
experiments). We then look at forces for each configuration and choose
the largest amplitude for which the forces are still in the linear
regime.

The supercell is still specified using `dim` (in this case `2x2x2`),
but the DOS sampling for frequencies to module with happens on the
specified grid (specified by `mesh`). By choosing a finer mesh, the
resolution (and number) of frequency samples in the DOS
increases. Modulations are chosen from this distribution according to
the `sampling` setting.

Liquid Database
***************

Liquid databases are constructed using sub-sampled MD calculations.

.. code-block:: yaml

   - type: 'liquid.LiquidDatabase'
     nconfigs: 1000
     samplerate: 100
     tstart:
       PdAg25: 2766
       PdAg50: 3063
       PdAg75: 3360
     tend:
       PdAg25: 2800
       PdAg50: 3100
       PdAg75: 3400
     incar:
       smass: 3
       potim: 1.

This tells `matdb` to run molecular dynamics for `1000 x 100` fs to
generate 1000 subsamples at intervals of 100 fs. The starting
temperature `tstart` for each seed configuration is set to be close to
its melting point. `tend` specifies the end temperature. These
settings are passed directly to the DFT calculation and behave as
documented there.

Notice that we also need to update some INCAR parameters to get MD to
work. We don't have to specify all of them because the defaults from
earlier in the specification will be used if not overridden.

`training` Options
*****************

Once a database of configurations is available, `matdb` can automate
the fits for you using these settings.

.. code-block:: yaml
		
   training:
     configs: ['PdAg25', 'PdAg50', 'PdAg75']
     execution:
       template: 'run_teachsparse_ml.sh'
       time: 10
       ntasks: 8
       mem_per_cpu: 5
       job_name: 'AgPd GAP'
     split: 0.5
     hessian_delta: 0.01
     gap: ['2body', '3body', 'soap']
     2body:
       cutoff: 6.0
       cutoff_transition_width: 1.0
       n_sparse: 20
     3body:
       cutoff: 3.5
       cutoff_transition_width: 0.5
       n_sparse: 200
     soap:
       l_max: 12
       n_max: 12
       cutoff: 5.0
       n_sparse: 200
       sparse_method: 'file'


- **configs**: list of the seed configs to include in the fit; the
  combined databases for each of these configs become the training
  data for the fit.
- **execution**: as described above, this specifies the template for
  executing the fits.
- **split**: how much data to use for training vs. validation.
- **hessian_delta**: if a hessian fit should be performed, then this
  is the delta to include. Specifying a delta here causes `matdb` to
  generate some hard-coded sparse points to include as a file in the
  `soap` fit (which corresponds to `sparse_method=file`).
- **gap**: list of GAP models to include in the final potential.

For each of the potential types specified in `gap` you can then add a
dictionary with parameters specific to that GAP (and which are passed
into the `teach_sparse` program). These work as documented there.
